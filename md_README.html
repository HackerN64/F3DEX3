<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F3DEX3: F3DEX3</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">F3DEX3
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_README.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">F3DEX3</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> Modern microcode for N64 romhacks. Will make you want to finally ditch HLE. Heavily modified version of F3DEX2, partially rewritten from scratch.</p>
<p><b>F3DEX3 is in alpha. It is not guaranteed to be bug-free, and updates may bring breaking changes.</b></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Features</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
New visual features</h2>
<ul>
<li>New geometry mode bit <code>G_PACKED_NORMALS</code> enables <b>simultaneous vertex colors and normals/lighting on the same mesh</b>, by encoding the normals in the unused 2 bytes of each vertex using a variant of <a href="https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/">octahedral encoding</a>. The normals are effectively as precise as with the vanilla method of replacing vertex RGB with normal XYZ.</li>
<li>New geometry mode bit <code>G_AMBOCCLUSION</code> enables <b>ambient occlusion</b> for opaque materials. Paint the shadow map into the vertex alpha channel; separate factors (set with <code>SPAmbOcclusion</code>) control how much this affects the ambient light, all directional lights, and all point lights.</li>
<li>New geometry mode bit <code>G_LIGHTTOALPHA</code> moves light intensity (maximum of R, G, and B of what would normally be the shade color after lighting) to shade alpha. Then, if <code>G_PACKED_NORMALS</code> is also enabled, the shade RGB is set to the vertex RGB. Together with alpha compare and some special display lists from fast64 which draw triangles two or more times with different CC settings, this enables <b>cel shading</b>. Besides cel shading, <code>G_LIGHTTOALPHA</code> can also be used for <a href="https://renderu.com/en/spookyiluhablog/post/23631">bump mapping</a> or other unusual CC effects (e.g. texture minus vertex color times lighting).</li>
<li>New geometry mode bits <code>G_FRESNEL_COLOR</code> or <code>G_FRESNEL_ALPHA</code> enable <b>Fresnel</b>. The dot product between a vertex normal and the vector from the vertex to the camera is computed; this is then scaled and offset with settable factors. The resulting value is then stored to shade color or shade alpha. This is useful for:<ul>
<li>making surfaces like water and glass fade between transparent when viewed straight-on and opaque when viewed at a large angle</li>
<li>applying a fake "outline" around the border of meshes</li>
<li>the N64 bump mapping implementation mentioned above</li>
</ul>
</li>
<li>New geometry mode bit <code>G_LIGHTING_SPECULAR</code> changes lighting computation from diffuse to <b>specular</b>. If enabled, the vertex normal for lighting is replaced with the reflection of the vertex-to-camera vector over the vertex normal. Also, a new size value for each light controls how large the light reflection appears to be. This technique is lower fidelity in some ways than the vanilla <code>hilite</code> system, as it is per-vertex rather than per-pixel, but it allows the material to be textured normally. Plus, it supports all scene lights (including point) with different dynamic colors, whereas the vanilla system supports up to two directional lights and more than one dynamic color is difficult.</li>
<li>New geometry mode bits <code>G_ATTROFFSET_ST_ENABLE</code> and <code>G_ATTROFFSET_Z_ENABLE</code> apply settable offsets to vertex ST (<code>SPAttrOffsetST</code>) and/or Z (<code>SPAttrOffsetZ</code>) values. These offsets are applied after their respective scales. For Z, this enables a method of drawing coplanar surfaces like decals but <b>without the Z fighting</b> which can happen with the RDP's native decal mode. For ST, this enables <b>UV scrolling</b> without CPU intervention.</li>
</ul>
<h2><a class="anchor" id="autotoc_md3"></a>
Performance improvements</h2>
<ul>
<li><b>56 verts</b> can fit into DMEM at once, up from 32 verts in F3DEX2, and only 13% below the 64 verts of reject microcodes. This reduces DRAM traffic and RSP time as fewer verts have to be reloaded and re-transformed, and also makes display lists shorter.</li>
<li>New <b>occlusion plane</b> system allows the placement of a 3D quadrilateral where objects behind this plane in screen space are culled. This can dramatically improve RDP performance by reducing overdraw in scenes with walls in the middle, such as a city or an indoor scene.</li>
<li>If a material display list being drawn is the same as the last material, the texture loads in the material are skipped (the second time). This effectively results in <b>auto-batched rendering</b> of repeated objects, as long as each only uses one material. This system supports multitexture and all types of loads. If this system incorrectly culls supposedly repeated texture loads which actually differ due to segment manipulation, you can locally disable it using the new <code>SPDontSkipTexLoadsAcross</code> command.</li>
<li>New <code>SPTriangleStrip</code> and <code>SPTriangleFan</code> commands <b>pack up to 5 tris</b> into one 64-bit GBI command (up from 2 tris in F3DEX2). In any given object, most tris can be drawn with these commands, with only a few at the end drawn with <code>SP2Triangles</code> or <code>SP1Triangle</code>. So, this cuts the triangle portion of display lists roughly in half, saving DRAM traffic and ROM space.</li>
<li>New <code>SPAlphaCompareCull</code> command enables culling of triangles whose computed shade alpha values are all below or above a settable threshold. This <b>substantially reduces the performance penalty of cel shading</b>&ndash;only tris which "straddle" the cel threshold are drawn twice, the others are only drawn once.</li>
<li>A new "hints" system encodes the expected size of the target display list into call, branch, and return DL commands. This allows only the needed number of DL commands in the next DL to be fetched, rather than always fetching full buffers, <b>saving some DRAM traffic</b> (maybe around 100 us per frame). The bits used for this are ignored by HLE.</li>
<li>Segment addresses are now resolved relative to other segments (feature by Tharo). This enables a strategy for <b>skipping repeated material DLs</b>: call a segment to run the material, remap the segment in the material to a display list that immediately returns, and so if the material is called again it won't run.</li>
<li>New <code>SPMemset</code> command fills a specified RDRAM region with a repeated 16-bit value. This can be used for clearing the Z buffer or filling the framebuffer or the letterbox with a solid color <b>faster than the RDP can in fill mode</b>. Practical performance may vary due to scheduling constraints.</li>
</ul>
<h2><a class="anchor" id="autotoc_md4"></a>
Miscellaneous</h2>
<ul>
<li><b>Point lighting</b> has been redesigned. The appearance when a light is close to an object has been improved. Fixed a bug in F3DEX2/ZEX point lighting where a Z component was accidentally doubled in the point lighting calculations. The quadratic point light attenuation factor is now an E3M5 floating-point number. The performance penalty for using large numbers of point lights has been reduced.</li>
<li>Maximum number of directional / point <b>lights raised from 7 to 9</b>. Minimum number of directional / point lights lowered from 1 to 0 (F3DEX2 required at least one). Also supports loading all lights in one DMA transfer (<code>SPSetLights</code>), rather than one per light.</li>
<li>New <code>SPLightToRDP</code> family of commands (e.g. <code>SPLightToPrimColor</code>) writes a selectable RDP command (e.g. <code>DPSetPrimColor</code>) with the RGB color of a selectable light (any including ambient). The alpha channel and any other parameters are encoded in the command. With some limitations, this allows the tint colors of cel shading to <b>match scene lighting</b> with no code intervention. Also useful for other lighting-dependent effects.</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Profiling</h2>
<p>F3DEX3 introduces a suite of performance profiling capabilities. These take the form of performance counters, which report cycle counts for various operations or the number of items processed of a given type. There are a total of 21 performance counters across multiple microcode versions. See the Profiling section below.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Microcode Configuration</h1>
<p>There are several selectable configuration settings when building F3DEX3, which can be enabled in any combination. With a couple minor exceptions, none of these settings affect the GBI&ndash;in fact, you can swap between the microcode versions on a per-frame basis if you build multiple versions into your romhack.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
No Occlusion Plane (NOC)</h2>
<p>If you are not using the occlusion plane feature in your romhack, you can use this configuration, which removes the computation of the occlusion plane in the vertex processing pipeline, saving some RSP time.</p>
<p>If you care about performance, please do consider using the occlusion plane! RDP time savings of 3-4 ms are common in scenes with reasonable occlusion planes, and even saving a third of the total RDP time can sometimes happen. Furthermore, when even a small percentage of the total triangles drawn are occluded, not only is RDP time saved (which is the point), but RSP time is also saved from not having to process those tris. This can offset the extra RSP time for computing the occlusion plane for all vertices.</p>
<p>You can also build both the NOC and base microcodes into your ROM and switch between them on a per-frame basis. If there is no occlusion plane active or the best occlusion plane candidate would be very small on screen, you can use the NOC microcode and save RSP time. If there is a significant occlusion plane, you can use the base microcode and reduce the RDP time. You could also determine which version to use on the profiling results from the previous frame: if the RSP is the bottleneck (e.g. the RDP <code>CLK - CMD</code> is high), use the NOC version, and otherwise use the base version.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Legacy Vertex Pipeline (LVP)</h2>
<p>The primary tradeoff for all the new lighting features in F3DEX3 is increased RSP time for vertex processing. The base version of F3DEX3 takes about <b>2-2.5x</b> more RSP time for vertex processing than F3DEX2 (see Performance Results section below), assuming no lighting or directional lights only. However, under most circumstances, this does not affect the game's overall framerate:</p><ul>
<li>This only applies to vertex processing, not triangle processing or other miscellaneous microcode tasks. So the total RSP cycles spent doing useful work during the frame is only modestly increased.</li>
<li>The increase in time is only RSP cycles; there is no additional memory traffic, so the RDP time is not directly affected.</li>
<li>In scenes which are complex enough to fill the RSP-&gt;RDP FIFO in DRAM, the RSP usually spends a significant fraction of time waiting for the FIFO to not be full (as revealed by the F3DEX3 performance counters, see below). In these cases, slower vertex processing simply means less time spent waiting, and little to no change in total RSP time.</li>
<li>When the FIFO does not fill up, usually the RSP takes significantly less time during the frame compared to the RDP, so increased RSP time usually does not affect the overall framerate.</li>
</ul>
<p>As a result, you should always start with the base version of F3DEX3 in your romhack, and if the RSP never becomes the bottleneck, you can stick with that.</p>
<p>However, if you have done extreme optimizations in your game to reduce RDP time (i.e. if you are Kaze Emanuar), it's possible for the RSP to sometimes become the bottleneck with F3DEX3's advanced vertex processing. As a result, the Legacy Vertex Pipeline (LVP) configuration has been introduced.</p>
<p>This configuration replaces F3DEX3's native vertex and lighting code with a faster version based on the same algorithms as F3DEX2. This removes:</p><ul>
<li>Point lighting</li>
<li>F3DEX3 lighting features: packed normals, ambient occlusion, light-to-alpha (cel shading), Fresnel, and specular lighting</li>
<li>ST attribute offsets</li>
</ul>
<p>However, it retains all other F3DEX3 features:</p><ul>
<li>56 verts, 9 directional lights</li>
<li>Occlusion plane (optional with NOC configuration)</li>
<li>Z attribute offsets</li>
<li>All features not related to vertex/lighting: auto-batched rendering, packed 5 triangles commands, hints system, etc.</li>
</ul>
<p>The performance of F3DEX3 vertex processing with both LVP and NOC is almost the same as that of F3DEX2; see the Performance Results section below.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Profiling</h2>
<p>As mentioned above, F3DEX3 includes many performance counters. There are far too many counters for a single microcode to maintain, so multiple configurations of the microcode can be built, each containing a different set of performance counters. These can be swapped while the game is running so the full set of counters can be effectively accessed over multiple frames.</p>
<p>There are a total of 21 performance counters, including:</p><ul>
<li>Counts of vertices, triangles, rectangles, matrices, DL commands, etc.</li>
<li>Times the microcode was processing vertices, processing triangles, stalled because the RDP FIFO in DMEM was full, and stalled waiting for DMAs to finish</li>
<li>A counter enabling a rough measurement of how long the RDP was stalled waiting for RDRAM for I/O to the framebuffer / Z buffer</li>
</ul>
<p>The default configuration of F3DEX3 provides a few of the most basic counters. The additional profiling configurations, called A, B, and C (for example <code>F3DEX3_BrZ_PA</code>), provide additional counters, but have two default features removed to make space for the extra profiling. These two features were selected because their removal does not affect the RDP render time.</p><ul>
<li>The <code>SPLightToRDP</code> commands are removed (they become no-ops)</li>
<li>Flat shading mode, i.e. <code>!G_SHADING_SMOOTH</code>, is removed (all tris are smooth)</li>
</ul>
<h2><a class="anchor" id="autotoc_md10"></a>
Branch Depth Instruction (<code>BrZ</code> / <code>BrW</code>)</h2>
<p>Use <code>BrZ</code> if the microcode is replacing F3DEX2 or an earlier F3D version (i.e. SM64), or <code>BrW</code> if the microcode is replacing F3DZEX (i.e. OoT or MM). This controls whether <code>SPBranchLessZ*</code> uses the vertex's W coordinate or screen Z coordinate.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Debug Normals (<code>dbgN</code>)</h2>
<p>To help debug lighting issues when integrating F3DEX3 into your romhack, this feature causes the vertex colors of any material with lighting enabled to be set to the transformed, normalized world space normals. The X, Y, and Z components map to R, G, and B, with each dimension's conceptual (-1.0 ... 1.0) range mapped to (0 ... 255). This is not compatible with LVP as world space normals do not exist in that pipeline. This also breaks vertex alpha and texgen / lookat.</p>
<p>Some ways to use this for debugging are:</p><ul>
<li>If the normals have obvious problems (e.g. flickering, or not changing smoothly as the object rotates / animates), there is likely a problem with the model space normals or the M matrix. Conversely, if there is a problem with the standard lighting results (e.g. flickering) but the normals don't have this problem, the problem is likely in the lighting data.</li>
<li>Check that the colors don't change based on the camera position, but DO change as the object rotates, so that the same side of an object in world space is always the same color.</li>
<li>Make a simple object like an octahedron or sphere, view it in game, and check that the normals are correct. A normal pointing along +X would be (1.0, 0.0, 0.0), meaning (255, 128, 128) or pink. A normal pointing along -X would be (-1.0, 0.0, 0.0), meaning (0, 128, 128) or dark cyan. Bright, fully saturated colors like green (0, 255, 0), yellow (255, 255, 0), or black should never appear as these would correspond to impossibly long normals.</li>
<li>Make the same object (octahedron is easiest in this case) with vertex colors which match what the normals should be, and compare them.</li>
</ul>
<h1><a class="anchor" id="autotoc_md12"></a>
Performance Results</h1>
<p>Vertex pipeline cycles per <b>vertex pair</b> in steady state (lower is better). Hand-counted timings taking into account all pipeline stalls and all dual-issue conditions except for instruction alignment.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Microcode   </th><th class="markdownTableHeadNone">No Lighting   </th><th class="markdownTableHeadNone">First Dir Lt   </th><th class="markdownTableHeadNone">Total for 1 Dir Lt   </th><th class="markdownTableHeadNone">Extra Dir Lts    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">F3DEX3   </td><td class="markdownTableBodyNone">98   </td><td class="markdownTableBodyNone">103   </td><td class="markdownTableBodyNone">201   </td><td class="markdownTableBodyNone">29    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">F3DEX3_NOC   </td><td class="markdownTableBodyNone">79   </td><td class="markdownTableBodyNone">103   </td><td class="markdownTableBodyNone">182   </td><td class="markdownTableBodyNone">29    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">F3DEX3_LVP   </td><td class="markdownTableBodyNone">81   </td><td class="markdownTableBodyNone">15   </td><td class="markdownTableBodyNone">96   </td><td class="markdownTableBodyNone">7    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">F3DEX3_LVP_NOC   </td><td class="markdownTableBodyNone">62   </td><td class="markdownTableBodyNone">15   </td><td class="markdownTableBodyNone">77   </td><td class="markdownTableBodyNone">7    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">F3DEX2   </td><td class="markdownTableBodyNone">54   </td><td class="markdownTableBodyNone">19   </td><td class="markdownTableBodyNone">73   </td><td class="markdownTableBodyNone">3 then 12   </td></tr>
</table>
<p>Vertex processing time as reported by the performance counter in the <code>PA</code> configuration.</p><ul>
<li>Scene 1: Kakariko, adult day, from DMT entrance</li>
<li>Scene 2: Custom empty scene with Suzanne monkey head with 1 dir light</li>
<li>Scene 3: Same but Suzanne has vertex colors instead of lighting (Link is still on screen and has lighting)</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Microcode   </th><th class="markdownTableHeadNone">Scene 1   </th><th class="markdownTableHeadNone">Scene 2   </th><th class="markdownTableHeadNone">Scene 3    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">F3DEX3   </td><td class="markdownTableBodyNone">7.64ms   </td><td class="markdownTableBodyNone">3.13ms   </td><td class="markdownTableBodyNone">2.37ms    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">F3DEX3_NOC   </td><td class="markdownTableBodyNone">7.07ms   </td><td class="markdownTableBodyNone">2.89ms   </td><td class="markdownTableBodyNone">2.14ms    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">F3DEX3_LVP   </td><td class="markdownTableBodyNone">4.57ms   </td><td class="markdownTableBodyNone">1.77ms   </td><td class="markdownTableBodyNone">1.67ms    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">F3DEX3_LVP_NOC   </td><td class="markdownTableBodyNone">3.96ms   </td><td class="markdownTableBodyNone">1.52ms   </td><td class="markdownTableBodyNone">1.41ms    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">F3DEX2   </td><td class="markdownTableBodyNone">No*   </td><td class="markdownTableBodyNone">No*   </td><td class="markdownTableBodyNone">No*    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Vertex count   </td><td class="markdownTableBodyNone">3664   </td><td class="markdownTableBodyNone">1608   </td><td class="markdownTableBodyNone">1608   </td></tr>
</table>
<p>*F3DEX2 does not contain performance counters, so the portion of the RSP time taken for vertex processing cannot be measured.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Porting Your Romhack Codebase to F3DEX3</h1>
<p>For an OoT codebase, only a few minor changes are required to use F3DEX3. However, more changes are recommended to increase performance and enable new features.</p>
<p>How to modify the microcode in your HackerOoT based romhack (steps may be similar for other games):</p><ul>
<li>Replace <code>include/ultra64/gbi.h</code> in your romhack with <code>gbi.h</code> from this repo.</li>
<li>Make the "Required Changes" listed below.</li>
<li>Build this repo: install the latest version of <code>armips</code>, then <code>make F3DEX3_BrZ</code> or <code>make F3DEX3_BrW</code>.</li>
<li>Copy the microcode binaries (<code>build/F3DEX3_X/F3DEX3_X.code</code> and <code>build/F3DEX3_X/F3DEX3_X.data</code>) to somewhere in your romhack repo, e.g. <code>data</code>.</li>
<li>In <code>data/rsp.rodata.s</code>, change the line between <code>fifoTextStart</code> and <code>fifoTextEnd</code> to <code>.incbin "data/F3DEX3_X.code"</code> (or wherever you put the binary), and similarly change the line between <code>fifoDataStart</code> and <code>fifoDataEnd</code> to <code>.incbin "data/F3DEX3_X.data"</code>. After both the <code>fifoTextEnd</code> and <code>fifoDataEnd</code> labels, add a line <code>.balign 16</code>.</li>
<li>If you are planning to ever update the microcode binaries in the future, add the following to the Makefile of your romhack, after the section starting with <code>build/data/%.o</code> (i.e. two lines after that, with a blank line before and after): <code>build/data/rsp.rodata.o: data/F3DEX3_X.code data/F3DEX3_X.data</code>. It is not a mistake that this new line you are adding won't have a second indented line after it; it is like the <code>message_data_static</code> lines below that. This will tell <code>make</code> to rebuild <code>rsp.rodata.o</code>, which includes the microcode binaries, whenever they are changed.</li>
<li>Clean and build your romhack (<code>make clean</code>, <code>make</code>).</li>
<li>Test your romhack and confirm that everything works as intended.</li>
<li>Make as many of the "Recommended changes" listed below as possible.</li>
<li>If you start using new features in F3DEX3, make the "Changes required for new
  features" listed below.</li>
</ul>
<h2><a class="anchor" id="autotoc_md14"></a>
Required Changes</h2>
<p>Both OoT and SM64:</p>
<ul>
<li>Remove uses of internal GBI features which have been removed in F3DEX3 (see "C
  GBI Compatibility" section below for full list). In OoT, the only changes needed are:<ul>
<li>In <code>src/code/ucode_disas.c</code>, remove the switch statement cases for <code>G_LINE3D</code>, <code>G_MW_CLIP</code>, <code>G_MV_MATRIX</code>, <code>G_MVO_LOOKATX</code>, <code>G_MVO_LOOKATY</code>, and <code>G_MW_PERSPNORM</code>.</li>
<li>In <code>src/libultra/gu/lookathil.c</code>, remove the lines which set the <code>col</code>, <code>colc</code>, and <code>pad</code> fields.</li>
</ul>
</li>
<li>Change your game engine lighting code to set the <code>type</code> (formerly <code>pad1</code>) field to 0 in the initialization of any directional light (<code>Light_t</code> and derived structs like <code>Light</code> or <code>Lightsn</code>). F3DEX3 ignores the state of the <code>G_LIGHTING_POSITIONAL</code> geometry mode bit in all display lists, meaning both directional and point lights are supported for all display lists (including vanilla). The light is identified as directional if <code>type</code> == 0 or point if <code>kc</code> &gt; 0 (<code>kc</code> and <code>type</code> are the same byte). This change is required because otherwise garbage nonzero values may be put in the padding byte, leading directional lights to be misinterpreted as point lights.<ul>
<li>The change needed in OoT is: in <code>src/code/z_lights.c</code>, in <code>Lights_BindPoint</code>, <code>Lights_BindDirectional</code>, and <code>Lights_NewAndDraw</code>, set <code>l.type</code> to 0 right before setting <code>l.col</code>.</li>
</ul>
</li>
</ul>
<p>SM64 only:</p>
<ul>
<li>If you are using the vanilla lighting system where light directions are always fixed, the vanilla permanent light direction of <code>{0x28, 0x28, 0x28}</code> must be changed to <code>{0x49, 0x49, 0x49}</code>, or everything will be too dark. The former vector is not properly normalized, but F3D through F3DEX2 normalize light directions in the microcode, so it doesn't matter with those microcodes. In contrast, F3DEX3 normalizes vertex normals (after transforming them), but assumes light directions have already been normalized.</li>
<li>Matrix stack fix (world space lighting / view matrix in VP instead of in M) is basically required. If you <em>really</em> want camera space lighting, use matrix stack fix, transform the fixed camera space light direction by V inverse each frame, and send that to the RSP. This will be faster than the alternative (not using matrix stack fix and enabling <code>G_NORMALS_MODE_AUTO</code> to correct the matrix).</li>
</ul>
<h2><a class="anchor" id="autotoc_md15"></a>
Recommended Changes (Non-Lighting)</h2>
<ul>
<li>Clean up any code using the deprecated, hacky <code>SPLookAtX</code> and <code>SPLookAtY</code> to use <code>SPLookAt</code> instead (this is only a few lines change). Also remove any code which writes <code>SPClipRatio</code> or <code>SPForceMatrix</code>&ndash;these are now no-ops, so you might as well not write them.</li>
<li>Avoid using <code>G_MTX_MUL</code> in <code>SPMatrix</code>. That is, make sure your game engine computes a matrix stack on the CPU and sends the final matrix for each object / limb to the RSP, rather than multiplying matrices on the RSP. OoT already usually does the former for precision / accuracy reasons and only uses <code>G_MTX_MUL</code> in a couple places (e.g. view * perspective matrix); it is okay to leave those. This change is recommended because the <code>G_MTX_MUL</code> mode of <code>SPMatrix</code> has been moved to Overlay 4 in F3DEX3 (see below), making it substantially slower than it was in F3DEX2. It still functions the same though so you can use it if it's really needed.</li>
<li>Re-export as many display lists (scenes, objects, skeletons, etc.) as possible with fast64 set to F3DEX3 mode, to take advantage of the substantially larger vertex buffer, triangle packing commands, "hints" system, etc.</li>
<li><code>#define REQUIRE_SEMICOLONS_AFTER_GBI_COMMANDS</code> (at the top of, or before including, the GBI) for a more modern, OoT-style codebase where uses of GBI commands require semicolons after them. SM64 omits the semicolons sometimes, e.g. <code>gSPDisplayList(gfx++, foo) gSPEndDisplayList(gfx++);</code>. If you are using <code>-Wpedantic</code>, using this define is required.</li>
<li>Once everything in your romhack is ported to F3DEX3 and everything is stable, <code>#define NO_SYNCS_IN_TEXTURE_LOADS</code> (at the top of, or before including, the GBI) and fix any crashes or graphical issues that arise. Display lists exported from fast64 already do not contain these syncs, but vanilla display lists or custom ones using the texture loading multi-command macros do. Disabling the syncs saves a few percent of RDP cycles for each material setup; what percentage this is of the total RDP time depends on how many triangles are typically drawn between each material change. For more information, see the GBI documentation near this define.</li>
</ul>
<h2><a class="anchor" id="autotoc_md16"></a>
Recommended Changes (Lighting)</h2>
<ul>
<li>Change your game engine lighting code to load all lights in one DMA transfer with <code>SPSetLights</code>, instead of one-at-a-time with repeated <code>SPLight</code> commands. Note that if you are using a pointer (dynamically allocated) rather than a direct variable (statically allocated), you need to dereference it; see the docstring for this macro in the GBI.</li>
<li>If you still need to use <code>SPLight</code> somewhere after this, use <code>SPLight</code> only for directional / point lights and use <code>SPAmbient</code> for ambient lights. Directional / point lights are 16 bytes and ambient are 8, and the first 8 bytes are the same for both types, so normally it's okay to use <code>SPLight</code> instead of <code>SPAmbient</code> to write ambient lights too. However, the memory space reserved for lights in the microcode is 16*9+8 bytes, so if you have 9 directional / point lights and then use <code>SPLight</code> to write the ambient light, it will overflow the buffer by 8 bytes and corrupt memory.</li>
<li>Once you have made the above change for <code>SPAmbient</code>, increase the maximum number of lights in your engine from 7 to 9.</li>
<li>Consider setting lights once before rendering a scene and all actors, rather than setting lights before rendering each actor. OoT does the latter to emulate point lights in a scene with a directional light recomputed per actor. You can now just send those to the RSP as real point lights, regardless of whether the display lists are vanilla or new.</li>
<li>If you are porting a game which already had point lighting (e.g. Majora's Mask), note that the point light kc, kl, and kq factors have been changed, so you will need to redesign how game engine light parameters (e.g. "light
  radius") map to these parameters.</li>
</ul>
<h2><a class="anchor" id="autotoc_md17"></a>
Changes Required for New Features</h2>
<p>Each of these changes is required if you want to use the respective new feature, but is not necessary if you are not using it.</p>
<ul>
<li>For Fresnel and specular lighting: Whenever your code sends camera properties to the RSP (VP matrix, viewport, etc.), also send the camera world position to the RSP with <code>SPCameraWorld</code>. For OoT, this is not trivial because the game rendering creates and sets the view matrix in the main DL, then renders the game contents, then updates the camera, and finally retroactively modifies the view matrix at the beginning of the main DL. See the code in <code><a class="el" href="camera_8c.html">cpu/camera.c</a></code>.</li>
<li>For specular lighting: Set the <code>size</code> field of any <code>Light_t</code> and <code>PosLight_t</code> to an appropriate value based on the game engine parameters for that light.</li>
<li>For the occlusion plane: Bring the code from <code><a class="el" href="occlusionplane_8c.html">cpu/occlusionplane.c</a></code> into your game and follow the included instructions.</li>
<li>For the performance counters: See <code><a class="el" href="counters_8c.html">cpu/counters.c</a></code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md18"></a>
Backwards Compatibility with F3DEX2</h1>
<h2><a class="anchor" id="autotoc_md19"></a>
C GBI Compatibility</h2>
<p>F3DEX3 is backwards compatible with F3DEX2 at the C GBI level for all features and commands except:</p>
<ul>
<li>The <code>G_SPECIAL_*</code> command IDs have been removed. <code>G_SPECIAL_2</code> and <code>G_SPECIAL_3</code> were no-ops in F3DEX2, and <code>G_SPECIAL_1</code> was a trigger to recalculate the MVP matrix. There is no MVP matrix in F3DEX3 so this is useless.</li>
<li><code>G_LINE3D</code> (and <code>Gfx.line</code>) has been removed. This command did not actually work in F3DEX2 (it behaved as a no-op).</li>
<li><code>G_MW_CLIP</code> has been removed, and <code>SPClipRatio</code> has been converted into a no-op. Clipping is handled differently in F3DEX3 and the clip ratio cannot be changed from 2.</li>
<li><code>G_MV_MATRIX</code>, <code>G_MW_MATRIX</code>, and <code>G_MW_FORCEMTX</code> have been removed, and <code>SPForceMatrix</code> has been converted into a no-op. This is because there is no MVP matrix in F3DEX3.</li>
<li><code>G_MV_POINT</code> has been removed. This was not used in any command; it would have likely been used for debugging to copy vertices from DMEM to examine them. This does not affect <code>SPModifyVertex</code>, which is still supported.</li>
<li><code>G_MW_PERSPNORM</code> has been removed; <code>SPPerspNormalize</code> is still supported but is encoded differently, no longer using this define.</li>
<li><code>G_MVO_LOOKATX</code> and <code>G_MVO_LOOKATY</code> have been removed, and <code>SPLookAtX</code> and <code>SPLookAtY</code> are deprecated. <code>SPLookAtX</code> has been changed to set both directions and <code>SPLookAtY</code> has been converted to a no-op. To set the lookat directions, use <code>SPLookAt</code>. The lookat directions are now in one 8-byte DMA word, so they must always be set at the same time as each other. Most of the non-functional fields (e.g. color) of <code>LookAt</code> and its sub-types have been removed, so code which accesses these fields needs to change. Code which only accesses lookat directions should be compatible with no changes.</li>
<li>As discussed above, the <code>pad1</code> field of <code>Light_t</code> is renamed to <code>type</code> and must be set to zero.</li>
<li>If you do not raise the maximum number of lights from 7 to 9, the lighting GBI commands are backwards compatible. However, if you do raise the number of lights, you must use <code>SPAmbient</code> to write the ambient light, as discussed above. Note that you can now load all your lights with one command, <code>SPSetLights</code>, so it is not usually necessary to use <code>SPLight</code> and <code>SPAmbient</code> at all.</li>
</ul>
<h2><a class="anchor" id="autotoc_md20"></a>
Binary Display List Compatibility</h2>
<p>F3DEX3 is generally binary backwards compatible with OoT-style display lists for objects, scenes, etc. <b>It is not compatible at the binary level with SM64-style display lists which encode object colors as light colors</b>, as all the command encodings related to lighting have changed. Of course, if you recompile these display lists with the new <code>gbi.h</code>, it can run them.</p>
<p>The deprecated commands mentioned above in the C GBI section have had their encodings changed (the original encodings will do bad things / crash). In addition, all lighting-related commands&ndash;e.g. <code>gdSPDefLights*</code>, <code>SPNumLights</code>, <code>SPLight</code>, <code>SPLightColor</code>, <code>SPLookAt</code>&ndash;have had their encodings changed, making them binary incompatible. The lighting data structures, e.g. <code>Light_t</code>, <code>PosLight_t</code>, <code>LookAt_t</code>, <code>Lightsn</code>, <code>Lights*</code>, <code>PosLights*</code>, etc., have also changed&ndash;generally only slightly, so most code is compatible with no changes.</p>
<p><code>SPSegment</code> has been given a different command id (<code>G_RELSEGMENT</code> vs. <code>G_MOVEWORD</code>) to facilitate relative segmented address translation. The original binary encoding is still valid, but does not support relative translation like the new encoding. However, recompiling with the C GBI will always use the new encoding.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
What are the tradeoffs for all these new features?</h1>
<h2><a class="anchor" id="autotoc_md22"></a>
Vertex Processing RSP Time</h2>
<p>See the Microcode Configuration and Performance Results sections above.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Overlay 4</h2>
<p>(Note that in the LVP configuration, Overlay 4 is absent; there is no M inverse transpose matrix discussed below, and the other commands mentioned below are directly in the microcode without an overlay, due to there being enough IMEM space.)</p>
<p>F3DEX2 contains Overlay 2, which does lighting, and Overlay 3, which does clipping (run on any large triangle which extends a large distance offscreen). These overlays are more RSP assembly code which are loaded into the same space in IMEM. If the wrong overlay is loaded when the other is needed, the proper one is loaded and then code jumps to it. Display lists which do not use lighting can stay on Overlay 3 at all times. Display lists for things that are typically relatively small on screen, such as characters, can stay on Overlay 2 at all times, because even when a triangle overlaps the edge of the screen, it typically moves fully off the screen and is discarded before it reaches the clipping bounds (2x the screen size).</p>
<p>In F3DEX2, the only case where the overlays are swapped frequently is for scenes with lighting, because they have large triangles which often extend far offscreen (Overlay 3) but also need lighting (Overlay 2). Worst case, the RSP will load Overlay 2 once for every <code>SPVertex</code> command and then load Overlay 3 for every set of <code>SP*Triangle*</code> commands.</p>
<p>(If you're curious, Overlays 0 and 1 are not related to 2 and 3, and have to do with starting and stopping RSP tasks. During normal display list execution, Overlay 1 is always loaded.)</p>
<p>F3DEX3 introduces Overlay 4, which can occupy the same IMEM as Overlay 2 and 3. This overlay contains handlers for:</p><ul>
<li>Computing the inverse transpose of the model matrix M (abbreviated as mIT), discussed below</li>
<li>The codepath for <code>SPMatrix</code> with <code>G_MTX_MUL</code> set (base version only; this is moved out of the overlay to normal microcode in the NOC configuration due to having extra IMEM space available)</li>
<li><code>SPBranchLessZ*</code></li>
<li><code>SPDma_io</code></li>
</ul>
<p>Whenever any of these features is needed, the RSP has to swap to Overlay 4. The next time lighting or clipping is needed, the RSP has to then swap back to Overlay 2 or 3. The round-trip of these two overlay loads takes about 5 microseconds of DRAM time including overheads. Fortunately, all the above features other than the mIT matrix are rarely or never used.</p>
<p>The mIT matrix is needed in F3DEX3 because normals are covectors&ndash;they stretch in the opposite direction of an object's scaling. So while you multiply a vertex by M to transform it from model space to world space, you have to multiply a normal by M inverse transpose to go to world space. F3DEX2 solves this problem by instead transforming light directions into model space with M transpose, and computing the lighting in model space. However, this requires extra DMEM to store the transformed lights, and adds an additional performance penalty for point lighting which is absent in F3DEX3. Plus, having world space normals in F3DEX3 enables Fresnel and specular lighting.</p>
<p>If an object's transformation matrix stack only includes translations, rotations, and uniform scale (i.e. same scale in X, Y, and Z), then M inverse transpose is just a rescaled version of M, and the normals can be transformed with M directly. It is only when the matrix includes nonuniform scales or shear that M inverse transpose differs from M. The difference gets larger as the scale or shear gets more extreme.</p>
<p>F3DEX3 provides three options for handling this (see <code>SPNormalsMode</code>):</p><ul>
<li><code>G_NORMALS_MODE_FAST</code>: Use M to transform normals. No performance penalty. Lighting will be somewhat distorted for objects with nonuniform scale or shear.</li>
<li><code>G_NORMALS_MODE_AUTO</code>: The RSP will automatically compute M inverse transpose whenever M changes. Costs about 3.5 microseconds of DRAM time per matrix, i.e. per object or skeleton limb which has lighting enabled. Lighting is correct for nonuniform scale or shear.</li>
<li><code>G_NORMALS_MODE_MANUAL</code>: You compute M inverse transpose on the CPU and manually upload it to the RSP every time M changes.</li>
</ul>
<p>It is recommended to use <code>G_NORMALS_MODE_FAST</code> (the default) for most things, and use <code>G_NORMALS_MODE_AUTO</code> only for objects while they currently have a nonuniform scale (e.g. Mario only while he is squashed).</p>
<h2><a class="anchor" id="autotoc_md24"></a>
Optimizing for RSP code size</h2>
<p>A number of optimizations in F3DEX2 which saved a few cycles but took several more instructions have been removed. Outside of vertex processing, these have a very small impact on overall RSP time and no impact on RDP time.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Far clipping removal</h2>
<p>Far clipping is completely removed in F3DEX3. Far clipping is not intentionally used for performance or aesthetic reasons in levels in vanilla SM64 or OoT, though it can be seen in certain extreme cases. However, it is used on the SM64 title screen for the zoom-in on Mario's face, so this will look slightly different.</p>
<p>The removal of far clipping saved a bunch of DMEM space, and enabled other changes to the clipping implementation which saved even more DMEM space.</p>
<p>NoN (No Nearclipping) is also mandatory in F3DEX3, though this was already the microcode option used in OoT. Note that tris are still clipped at the camera plane; nearclipping means they are clipped at the nearplane, which is a short distance in front of the camera plane.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Removal of scaled vertex normals</h2>
<p>A few clever romhackers figured out that you could shrink the normals on verts in your mesh (so their length is less than "1") to make the lighting on those verts dimmer and create a version of ambient occlusion. In the base vertex pipeline, F3DEX3 normalizes vertex normals after transforming them, which is required for most features of the lighting system including packed normals, so this no longer works. However, F3DEX3 has support for ambient occlusion via vertex alpha, which accomplishes the same goal with some extra benefits:</p><ul>
<li>Much easier to create: just paint the vertex alpha in Blender / fast64. The scaled normals approach was not supported in fast64 and had to be done with scripts or by hand.</li>
<li>The amount of ambient occlusion in F3DEX3 can be set at runtime based on variable scene lighting, whereas the scaled normals approach is baked into the mesh.</li>
<li>F3DEX3 can have the vertex alpha affect ambient, directional, and point lights by different amounts, which is not possible with scaled normals. In fact, scaled normals never affect the ambient light, contrary to the concept of ambient occlusion.</li>
</ul>
<p>Furthermore, for partial HLE compatibility, the same mesh can have the ambient occlusion information encoded in both scaled normals and vertex alpha at the same time. HLE will ignore the vertex alpha AO but use the scaled normals; F3DEX3 will fix the normals' scale but then apply the AO.</p>
<p>The only case where scaled normals work but F3DEX3 AO doesn't work is for meshes with vertex alpha actually used for transparency (therefore also no fog).</p>
<p>Note that in LVP mode, scaled normals are supported and work the same way as in F3DEX2, while ambient occlusion is not supported.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
RDP temporary buffers shrinking</h2>
<p>In FIFO versions of F3DEX2, there are two DMEM buffers to hold RDP commands generated by the microcode, which are swapped and copied to the FIFO in DRAM. These each had the capacity of two-and-a-fraction full-size triangle commands (i.e. triangles with shade, texture, and Z-buffer). For short commands (e.g. texture loads, color combiner, etc.) there is a slight performance gain from having longer buffers in DMEM which are swapped to DRAM less frequently. And, if a substantial portion of triangles were rendered without shade or texture such that three tris could fit per buffer, being able to fit the three tris would also slightly improve performance. However, in practice, the vast majority of the FIFO is occupied by full-size tris, so the buffers are effectively only two tris in size because a third tri can't fit. So, their size has been reduced to two tris, saving a substantial amount of DMEM.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Segment 0</h2>
<p>Segment 0 is now reserved: ensure segment 0 is never set to anything but 0x00000000. In F3DEX2 and prior this was only a good idea (and SM64 and OoT always follow this); in F3DEX3 segmented addresses are now resolved relative to other segments. That is, <code>gsSPSegment(0x08, 0x07001000)</code> sets segment 8 to the base address of segment 7 with an additional offset of 0x1000. So for correct behavior when supplying a direct-mapped or physical address such as 0x80101000, segment 0 must always be 0x00000000 so that this address resolves to e.g. 0x101000 as expected in this example.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Obscure semantic differences from F3DEX2 that should never matter in practice</h2>
<ul>
<li><code>SPLoadUcode*</code> corrupts the current M inverse transpose matrix state. If using <code>G_NORMALS_MODE_FAST</code>, this doesn't matter. If using <code>G_NORMALS_MODE_AUTO</code>, you must send the M matrix to the RSP again after returning to F3DEX3 from the other microcode (which would normally be done anyway when starting to draw the next object). If using <code>G_NORMALS_MODE_MANUAL</code>, you must send the updated M inverse transpose matrix to the RSP after returning to F3DEX3 from the other microcode (which would normally be done anyway when starting to draw the next object).</li>
<li>Changing fog settings&ndash;i.e. enabling or disabling <code>G_FOG</code> in the geometry mode or executing <code>SPFogFactor</code> or <code>SPFogPosition</code>&ndash;between loading verts and drawing tris with those verts will lead to incorrect fog values for those tris. In F3DEX2, the fog settings at vertex load time would always be used, even if they were changed before drawing tris.</li>
</ul>
<h1><a class="anchor" id="autotoc_md30"></a>
What happened to the clipping minimal scanlines algorithm?</h1>
<p>Earlier F3DEX3 versions included a modified algorithm for triangulating the polygon which was formed as the result of clipping. This algorithm broke up the polygon into triangles in such a way that the fewest scanlines were accessed multiple times, leading to maximum performance on the RDP. For example, if the polygon was a diamond shape, this algorithm would always cut it horizontally&ndash; leading to few or no scanlines being touched by both the top and bottom tris&ndash;as opposed to vertically, leading to all scanlines being touched by the left and right tris.</p>
<p>In testing, this was able to save a few hundred microseconds at best in scenes with many large clipped tris. However, this feature has been removed, because it was found to cause undesirable visual artifacts. Other changes to clipping were experimented with in the past, and ultimately not included. These are not due to a bug or design issue with the microcode, but a fundamental limitation of the RDP: vertex colors are interpolated in screen space without perspective correction. In other words, the shade colors of any triangle not flat to the camera are slightly wrong&ndash;the same world space portion of the triangle will have a slightly different color depending on how the camera is rotated around it. The issues with clipping are a result of this.</p>
<p>To show why this is an unavoidable issue on the N64, here is an example:</p>
<div class="image">
<img src="colorinterp.png" alt=""/>
<div class="caption">
Color interpolation example</div></div>
    <p>A: The triangle has vertex colors 0, 128, 255 (same for all three color components) as shown. It is clipped off the left side of the screen halfway through its world-space coordinates, so the generated vertices have colors 64 and 192 respectively.</p>
<p>B: Due to perspective and the clipped vertex being near the camera plane, the clipped polygon is distorted to this shape.</p>
<p>C: If this polygon is triangulated this way, the point in the middle of the polygon has color 160 (halfway between 64 and 255).</p>
<p>D: If this polygon is instead triangulated this way, the point in the middle of the polygon has color 96 (halfway between 192 and 0).</p>
<p>Note that BOTH of these are wrong: the correct value for that pixel is 128, because all points on the horizontal midline of the original triangle are color</p><ol type="1">
<li>The N64 can't draw the correct triangle here&ndash;its colors would have to change nonlinearly along an edge.</li>
</ol>
<p>The problem with the clipping minimal scanlines algorithm is that it would switch between cases C and D here based on which diagonal had a larger Y component. In other words, if the camera moved slightly, the choice of triangulation might change, causing the middle of the polygon to visibly change color. This was visible on large scene triangles with lighting: as you walked around, the colors would have slight but abrupt changes, which look wrong/bad.</p>
<p>The best we can do, which is what all previous F3D family microcodes did and F3DEX3 does now, is to triangulate in a consistent way, based on the winding of the input triangles. The results are still wrong, but they're wrong the same way every frame, so there are no abrupt changes visible.</p>
<h1><a class="anchor" id="autotoc_md31"></a>
Credits</h1>
<p>F3DEX3 modifications from F3DEX2 are by Sauraen and are dedicated to the public domain. <code>cpu/</code> C code is entirely by Sauraen and also dedicated to the public domain.</p>
<p>If you use F3DEX3 in a romhack, please credit "F3DEX3 Microcode - Sauraen" in your project's in-game Staff Roll or wherever other contributors to your project are credited.</p>
<p>Other contributors:</p><ul>
<li>Wiseguy: large chunk of F3DEX2 disassembly documentation and first version of build system</li>
<li>Tharo: relative segment resolution feature, other feature discussions</li>
<li>Kaze Emanuar: several feature suggestions, testing</li>
<li>thecozies: Fresnel feature suggestion</li>
<li>neoshaman: feature discussions </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
